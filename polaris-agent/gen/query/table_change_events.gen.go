// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/qianjisantech/gosmo-agent/gen/model"
)

func newTableChangeEvent(db *gorm.DB, opts ...gen.DOOption) tableChangeEvent {
	_tableChangeEvent := tableChangeEvent{}

	_tableChangeEvent.tableChangeEventDo.UseDB(db, opts...)
	_tableChangeEvent.tableChangeEventDo.UseModel(&model.TableChangeEvent{})

	tableName := _tableChangeEvent.tableChangeEventDo.TableName()
	_tableChangeEvent.ALL = field.NewAsterisk(tableName)
	_tableChangeEvent.ID = field.NewInt32(tableName, "id")
	_tableChangeEvent.TableName_ = field.NewString(tableName, "table_name")
	_tableChangeEvent.RowID = field.NewInt32(tableName, "row_id")
	_tableChangeEvent.ChangedField = field.NewString(tableName, "changed_field")
	_tableChangeEvent.NewValue = field.NewString(tableName, "new_value")

	_tableChangeEvent.fillFieldMap()

	return _tableChangeEvent
}

type tableChangeEvent struct {
	tableChangeEventDo tableChangeEventDo

	ALL          field.Asterisk
	ID           field.Int32
	TableName_   field.String
	RowID        field.Int32
	ChangedField field.String
	NewValue     field.String

	fieldMap map[string]field.Expr
}

func (t tableChangeEvent) Table(newTableName string) *tableChangeEvent {
	t.tableChangeEventDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tableChangeEvent) As(alias string) *tableChangeEvent {
	t.tableChangeEventDo.DO = *(t.tableChangeEventDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tableChangeEvent) updateTableName(table string) *tableChangeEvent {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt32(table, "id")
	t.TableName_ = field.NewString(table, "table_name")
	t.RowID = field.NewInt32(table, "row_id")
	t.ChangedField = field.NewString(table, "changed_field")
	t.NewValue = field.NewString(table, "new_value")

	t.fillFieldMap()

	return t
}

func (t *tableChangeEvent) WithContext(ctx context.Context) ITableChangeEventDo {
	return t.tableChangeEventDo.WithContext(ctx)
}

func (t tableChangeEvent) TableName() string { return t.tableChangeEventDo.TableName() }

func (t tableChangeEvent) Alias() string { return t.tableChangeEventDo.Alias() }

func (t tableChangeEvent) Columns(cols ...field.Expr) gen.Columns {
	return t.tableChangeEventDo.Columns(cols...)
}

func (t *tableChangeEvent) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tableChangeEvent) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 5)
	t.fieldMap["id"] = t.ID
	t.fieldMap["table_name"] = t.TableName_
	t.fieldMap["row_id"] = t.RowID
	t.fieldMap["changed_field"] = t.ChangedField
	t.fieldMap["new_value"] = t.NewValue
}

func (t tableChangeEvent) clone(db *gorm.DB) tableChangeEvent {
	t.tableChangeEventDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tableChangeEvent) replaceDB(db *gorm.DB) tableChangeEvent {
	t.tableChangeEventDo.ReplaceDB(db)
	return t
}

type tableChangeEventDo struct{ gen.DO }

type ITableChangeEventDo interface {
	gen.SubQuery
	Debug() ITableChangeEventDo
	WithContext(ctx context.Context) ITableChangeEventDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITableChangeEventDo
	WriteDB() ITableChangeEventDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITableChangeEventDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITableChangeEventDo
	Not(conds ...gen.Condition) ITableChangeEventDo
	Or(conds ...gen.Condition) ITableChangeEventDo
	Select(conds ...field.Expr) ITableChangeEventDo
	Where(conds ...gen.Condition) ITableChangeEventDo
	Order(conds ...field.Expr) ITableChangeEventDo
	Distinct(cols ...field.Expr) ITableChangeEventDo
	Omit(cols ...field.Expr) ITableChangeEventDo
	Join(table schema.Tabler, on ...field.Expr) ITableChangeEventDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITableChangeEventDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITableChangeEventDo
	Group(cols ...field.Expr) ITableChangeEventDo
	Having(conds ...gen.Condition) ITableChangeEventDo
	Limit(limit int) ITableChangeEventDo
	Offset(offset int) ITableChangeEventDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITableChangeEventDo
	Unscoped() ITableChangeEventDo
	Create(values ...*model.TableChangeEvent) error
	CreateInBatches(values []*model.TableChangeEvent, batchSize int) error
	Save(values ...*model.TableChangeEvent) error
	First() (*model.TableChangeEvent, error)
	Take() (*model.TableChangeEvent, error)
	Last() (*model.TableChangeEvent, error)
	Find() ([]*model.TableChangeEvent, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TableChangeEvent, err error)
	FindInBatches(result *[]*model.TableChangeEvent, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TableChangeEvent) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITableChangeEventDo
	Assign(attrs ...field.AssignExpr) ITableChangeEventDo
	Joins(fields ...field.RelationField) ITableChangeEventDo
	Preload(fields ...field.RelationField) ITableChangeEventDo
	FirstOrInit() (*model.TableChangeEvent, error)
	FirstOrCreate() (*model.TableChangeEvent, error)
	FindByPage(offset int, limit int) (result []*model.TableChangeEvent, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITableChangeEventDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tableChangeEventDo) Debug() ITableChangeEventDo {
	return t.withDO(t.DO.Debug())
}

func (t tableChangeEventDo) WithContext(ctx context.Context) ITableChangeEventDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tableChangeEventDo) ReadDB() ITableChangeEventDo {
	return t.Clauses(dbresolver.Read)
}

func (t tableChangeEventDo) WriteDB() ITableChangeEventDo {
	return t.Clauses(dbresolver.Write)
}

func (t tableChangeEventDo) Session(config *gorm.Session) ITableChangeEventDo {
	return t.withDO(t.DO.Session(config))
}

func (t tableChangeEventDo) Clauses(conds ...clause.Expression) ITableChangeEventDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tableChangeEventDo) Returning(value interface{}, columns ...string) ITableChangeEventDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tableChangeEventDo) Not(conds ...gen.Condition) ITableChangeEventDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tableChangeEventDo) Or(conds ...gen.Condition) ITableChangeEventDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tableChangeEventDo) Select(conds ...field.Expr) ITableChangeEventDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tableChangeEventDo) Where(conds ...gen.Condition) ITableChangeEventDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tableChangeEventDo) Order(conds ...field.Expr) ITableChangeEventDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tableChangeEventDo) Distinct(cols ...field.Expr) ITableChangeEventDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tableChangeEventDo) Omit(cols ...field.Expr) ITableChangeEventDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tableChangeEventDo) Join(table schema.Tabler, on ...field.Expr) ITableChangeEventDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tableChangeEventDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITableChangeEventDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tableChangeEventDo) RightJoin(table schema.Tabler, on ...field.Expr) ITableChangeEventDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tableChangeEventDo) Group(cols ...field.Expr) ITableChangeEventDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tableChangeEventDo) Having(conds ...gen.Condition) ITableChangeEventDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tableChangeEventDo) Limit(limit int) ITableChangeEventDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tableChangeEventDo) Offset(offset int) ITableChangeEventDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tableChangeEventDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITableChangeEventDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tableChangeEventDo) Unscoped() ITableChangeEventDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tableChangeEventDo) Create(values ...*model.TableChangeEvent) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tableChangeEventDo) CreateInBatches(values []*model.TableChangeEvent, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tableChangeEventDo) Save(values ...*model.TableChangeEvent) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tableChangeEventDo) First() (*model.TableChangeEvent, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TableChangeEvent), nil
	}
}

func (t tableChangeEventDo) Take() (*model.TableChangeEvent, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TableChangeEvent), nil
	}
}

func (t tableChangeEventDo) Last() (*model.TableChangeEvent, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TableChangeEvent), nil
	}
}

func (t tableChangeEventDo) Find() ([]*model.TableChangeEvent, error) {
	result, err := t.DO.Find()
	return result.([]*model.TableChangeEvent), err
}

func (t tableChangeEventDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TableChangeEvent, err error) {
	buf := make([]*model.TableChangeEvent, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tableChangeEventDo) FindInBatches(result *[]*model.TableChangeEvent, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tableChangeEventDo) Attrs(attrs ...field.AssignExpr) ITableChangeEventDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tableChangeEventDo) Assign(attrs ...field.AssignExpr) ITableChangeEventDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tableChangeEventDo) Joins(fields ...field.RelationField) ITableChangeEventDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tableChangeEventDo) Preload(fields ...field.RelationField) ITableChangeEventDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tableChangeEventDo) FirstOrInit() (*model.TableChangeEvent, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TableChangeEvent), nil
	}
}

func (t tableChangeEventDo) FirstOrCreate() (*model.TableChangeEvent, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TableChangeEvent), nil
	}
}

func (t tableChangeEventDo) FindByPage(offset int, limit int) (result []*model.TableChangeEvent, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tableChangeEventDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tableChangeEventDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tableChangeEventDo) Delete(models ...*model.TableChangeEvent) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tableChangeEventDo) withDO(do gen.Dao) *tableChangeEventDo {
	t.DO = *do.(*gen.DO)
	return t
}
